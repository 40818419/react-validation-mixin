{"name":"react-validation-mixin","tagline":"Simple validation mixin for React.","body":"# react-validation-mixin\r\nSimple validation mixin for React.\r\n\r\nThis library provides the boilerplate needed to validate a React component.\r\n\r\n**react-validation-mixin** aims to provide a low-to-mid level toolkit for *state or props* validation, relying on existing validation libraries. This mixin currently supports [Joi](https://github.com/hapijs/joi) which aligns perfectly with React.\r\n\r\nSimply define the validation schema using Joi validators, and the mixin will give you access to each fields validity and error messages.\r\n\r\n[View DEMO](http://jurassix.github.io/react-validation-mixin/)\r\n\r\n## Install\r\n\r\nInstall mixin via npm:\r\n\r\n    > npm install --save react-validation-mixin\r\n\r\nMake sure you install the peer dependency Joi:\r\n\r\n    > npm install --save joi\r\n\r\n*See [Joi](https://github.com/hapijs/joi) for a full list of api validation strategies available.*\r\n\r\n## Usage\r\n\r\n### `validatorTypes`\r\n\r\nvalidatorTypes is the Joi object schema defining the validity of a component.\r\n\r\nvalidatorTypes can be defined as an **object or function**, as long as a valid Joi schema is returned.\r\n\r\nYou do not have to provide validation for all state fields.\r\n\r\n*See [Joi](https://github.com/hapijs/joi) for a full list of api validation strategies available.*\r\n\r\n```javascript\r\n// defined as object\r\nvalidatorTypes: {\r\n  username: Joi.string().alphanum().min(3).max(30).required(),\r\n  password: Joi.string().regex(/[a-zA-Z0-9]{3,30}/)\r\n}\r\n\r\n// defined as function\r\nvalidatorTypes: function() {\r\n  return Joi.object().keys({\r\n    username: Joi.string().alphanum().min(3).max(30).required(),\r\n    password: Joi.string().regex(/[a-zA-Z0-9]{3,30}/)\r\n  });\r\n}\r\n\r\n// defined as a function with conditional component state\r\nvalidatorTypes: function() {\r\n  var base = Joi.object().keys({\r\n    firstName: Joi.string().required(),\r\n    lastName: Joi.string().allow(null),\r\n    email: Joi.string().email(),\r\n    username:  Joi.string().alphanum().min(3).max(30).required()\r\n  });\r\n  if (this.props.user.anonymous) {\r\n    return base.keys({\r\n      newPassword: Joi.string().regex(/[a-zA-Z0-9]{3,30}/),\r\n      verifyPassword: Joi.ref('newPassword')\r\n    });\r\n  } else {\r\n    return base;\r\n  }\r\n}\r\n```\r\n\r\n### `validate([key,] callback)`\r\n\r\nAsynchronous validation of entire form or specifc key if provided. Error-first callback will return an error if form or key is invalid.\r\n\r\nThis API allows developers to validate a single field or the entire form if no key is provided.\r\n\r\n```javascript\r\nthis.validate(function(error, data) {\r\n  if(error) {\r\n    // form contains errors\r\n    return;\r\n  }\r\n  // form is valid, fire action\r\n});\r\n\r\n```\r\n\r\n### `isValid([key])`\r\n\r\nreturns true|false depending on the validity of the current state.\r\n\r\nThis API is a wrapper around `this.state.errors`, that allows developers to check for the validity of a single field or entire form.\r\n\r\n```javascript\r\nthis.isValid('username'); // returns boolean for validity of only this field\r\n\r\nthis.isValid(); // returns boolean for validity of all fields in schema\r\n```\r\n\r\n### `getValidationMessages([key])`\r\n\r\nreturns an array of validation messages for this field.\r\n\r\nThis API is a wrapper around `this.state.errors`, that returns validations for a single key, or all validations.\r\n\r\n```javascript\r\nthis.getValidationMessages('username'); // returns array of messages for this field or empty array if valid\r\n\r\nthis.getValidationMessages(); // returns array of messages for all fields or empty array if valid\r\n```\r\n\r\n### `handleValidation([key, callback])`\r\n\r\nhigher order function that returns an event handler for asynchronous validation of specifc key or entire form if no key is provided. Optional error-first callback will return an error if form or key is invalid.\r\n\r\nThis is a simple wrapper around `this.validate(key, callback)`.\r\n\r\nAllows the developer to easily validate onBlur, onChange, etc.\r\n\r\n```javascript\r\nonBlur={this.handleValidation('username')} // returns an event handler to validate this field\r\n```\r\n\r\n### `getValidatorData`\r\n\r\nThis API provides a way for developers to validate props, state, or a combination of both.\r\n\r\n**By default, *react-validation-mixin* will only validate a components *state*.**\r\n\r\nvalidatorData should be defined as an **object or function**, as long as a valid Object is returned.\r\n\r\n```javascript\r\n// defined as object\r\nvalidatorData: this.props\r\n\r\n// defined as function\r\nvalidatorData: function() {\r\n  return Object.assign({}, this.props, this.state);\r\n}\r\n```\r\n\r\n### `this.state.errors`\r\n\r\nValidation results are stored on the components state, allowing developers direct access to the underlying validity of the form.\r\n\r\n# Example Component:\r\n\r\n```javascript\r\nvar React = require('react/addons');\r\nvar ValidationMixin = require('react-validation-mixin');\r\nvar Joi = require('joi');\r\n\r\nvar Signup = React.createClass({\r\n  displayName: 'Signup',\r\n  mixins: [ValidationMixin, React.addons.LinkedStateMixin],\r\n  validatorTypes:  {\r\n    firstName: Joi.string().required().label('First Name'),\r\n    lastName: Joi.string().allow(null).label('Last Name'),\r\n    email: Joi.string().email().label('Email Address'),\r\n    username:  Joi.string().alphanum().min(3).max(30).required().label('Username'),\r\n    password: Joi.string().regex(/[a-zA-Z0-9]{3,30}/).label('Password'),\r\n    verifyPassword: Joi.any().valid(Joi.ref('password')).required().label('Password Confirmation')\r\n  },\r\n  getInitialState: function() {\r\n    return {\r\n      firstName: null,\r\n      lastName: null,\r\n      email: null,\r\n      username: null,\r\n      password: null,\r\n      verifyPassword: null,\r\n      feedback: null\r\n    };\r\n  },\r\n  render: function() {\r\n    return (\r\n      <section className='row'>\r\n        <h3>Signup</h3>\r\n        <form onSubmit={this.handleSubmit} className='form-horizontal'>\r\n          <fieldset>\r\n            <div className={this.getClasses('firstName')}>\r\n              <label htmlFor='firstName'>First Name</label>\r\n              <input type='text' id='firstName' ref='firstName' valueLink={this.linkState('firstName')} onBlur={this.handleValidation('firstName')} className='form-control' placeholder='First Name' />\r\n              {this.getValidationMessages('firstName').map(this.renderHelpText)}\r\n            </div>\r\n            <div className={this.getClasses('lastName')}>\r\n              <label htmlFor='lastName'>Last Name</label>\r\n              <input type='text' id='lastName' valueLink={this.linkState('lastName')} onBlur={this.handleValidation('lastName')} className='form-control' placeholder='Last Name' />\r\n            </div>\r\n            <div className={this.getClasses('email')}>\r\n              <label htmlFor='email'>Email</label>\r\n              <input type='email' id='email' valueLink={this.linkState('email')} onBlur={this.handleValidation('email')}  className='form-control' placeholder='Email' />\r\n              {this.getValidationMessages('email').map(this.renderHelpText)}\r\n            </div>\r\n            <div className={this.getClasses('username')}>\r\n              <label htmlFor='username'>Username</label>\r\n              <input type='text' id='username' valueLink={this.linkState('username')} onBlur={this.handleValidation('username')} className='form-control' placeholder='Username' />\r\n              {this.getValidationMessages('username').map(this.renderHelpText)}\r\n            </div>\r\n            <div className={this.getClasses('password')}>\r\n              <label htmlFor='password'>Password</label>\r\n              <input type='password' id='password' valueLink={this.linkState('password')} onBlur={this.handleValidation('password')} className='form-control' placeholder='Password' />\r\n              {this.getValidationMessages('password').map(this.renderHelpText)}\r\n            </div>\r\n            <div className={this.getClasses('verifyPassword')}>\r\n              <label htmlFor='verifyPassword'>Verify Password</label>\r\n              <input type='password' id='verifyPassword' valueLink={this.linkState('verifyPassword')} onBlur={this.handleValidation('verifyPassword')}  className='form-control' placeholder='Verify Password' />\r\n              {this.getValidationMessages('verifyPassword').map(this.renderHelpText)}\r\n            </div>\r\n            <div className='form-group'>\r\n              <h3>{this.state.feedback}</h3>\r\n            </div>\r\n            <div className='text-center form-group'>\r\n              <button type='submit' className='btn btn-large btn-primary'>Sign up</button>\r\n              {' '}\r\n              <button onClick={this.handleReset} className='btn btn-large btn-info'>Reset</button>\r\n            </div>\r\n          </fieldset>\r\n        </form>\r\n      </section>\r\n    )\r\n  },\r\n  renderHelpText: function(message) {\r\n    return (\r\n      <span className=\"help-block\">{message}</span>\r\n    );\r\n  },\r\n  getClasses: function(field) {\r\n    return React.addons.classSet({\r\n      'form-group': true,\r\n      'has-error': !this.isValid(field)\r\n    });\r\n  },\r\n  handleReset: function(event) {\r\n    event.preventDefault();\r\n    this.clearValidations();\r\n    this.setState(this.getInitialState());\r\n  },\r\n  handleSubmit: function(event) {\r\n    event.preventDefault();\r\n    onValidate = function(error, validationErrors) {\r\n      if (error) {\r\n        this.setState({\r\n          feedback: 'Form is invalid do not submit'\r\n        });\r\n      } else {\r\n        this.setState({\r\n          feedback: 'Form is valid send to action creator'\r\n        });\r\n      }\r\n    }.bind(this);\r\n    this.validate(onValidate);\r\n  }\r\n});\r\n\r\nmodule.exports = Signup;\r\n```\r\n\r\n## Human readable errors\r\n\r\nMessages like \"serialNumber must be a number\" are not very friendly.\r\nJoi provides an option to override key name in message with [label](https://github.com/hapijs/joi#anylabelname) method.\r\n\r\n```javascript\r\nvalidatorTypes: function() {\r\n  return {\r\n    serialNumber: Joi.number().required().label(\"Serial Number\"),\r\n    assemblyDate: Joi.date().required().label(\"Assembly Date\"),\r\n    manufacturer: Joi.string().required().label(\"Manufacturer),\r\n  };\r\n}\r\n```\r\n\r\nBut you, probably, have already defined labels in your form declaration and don't want to repeat it again. To manually handle this it's possible to make `validatorTypes` a function and access field labels by `this.refs`.\r\n\r\n```javascript\r\nvalidatorTypes: function() {\r\n  return {\r\n    serialNumber: Joi.number().required().label(this.refs.serialNumber.props.label),\r\n    assemblyDate: Joi.date().required().label(this.refs.assemblyDate.props.label),\r\n    manufacturer: Joi.string().required().label(this.refs.manufacturer.props.label),\r\n  };\r\n},\r\n```\r\n\r\nIt's a bit more in-sync, but even more verbose :(\r\n\r\n## Release Notes\r\n\r\n4.0.0 (Major release with breaking API changes):\r\n\r\n  * `validatorData` is now `getValidatorData` to be more idiomatic of React\r\n  * `validate` now takes an error-first callback, which allows for a simpler API when validating on Submit. `validate` also takes an optional key as a first param that can be used to validate a single form field.\r\n  * `isValid` is now a simple wrapper around `this.state.errors` **see example for handling form submission in 4.x.x**\r\n  * `clearValidations` has been added to reset all current errors.\r\n  * `handleValidations` now takes a second parameter error-first callback that can be used for custom handling of errors.\r\n\r\n\r\n### _Please contribute suggestions, features, issues, and pull requests._\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}